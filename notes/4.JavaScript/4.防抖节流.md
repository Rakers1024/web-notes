# 防抖节流

防抖和节流都是为了阻止操作高频触发，从而浪费性能。

## 防抖

防抖是触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。适用于可以多次触发但触发只生效最后一次的场景。

函数实现：

::: code-group

```js [防抖函数]
function debounce(fn, delay){
	let timer = null;
	return function(){
		clearTimeout(timer);
		timer = setTimeout(()=> {
			fn.apply(this, arguments);
		}, delay)
	}
}
```

```vue [测试]
<script setup>
import { ref } from 'vue'
import VPButton from "vitepress/dist/client/theme-default/components/VPButton.vue";
  
const count = ref(0)
function debounce(fn, delay){
	let timer = null;
	return function(){
		clearTimeout(timer);
		timer = setTimeout(()=> {
			fn.apply(this, arguments);
		}, delay)
	}
}
</script>
<VPButton :text="`运行测试代码${count}`" @click="debounce(()=>count++, 2000)"/>
```

:::



<script setup>
import { ref } from 'vue'
import VPButton from "vitepress/dist/client/theme-default/components/VPButton.vue";

const count = ref(0)
function debounce(fn, delay){
	let timer = null;
	return function(){
		clearTimeout(timer);
		timer = setTimeout(()=> {
			fn.apply(this, arguments);
		}, delay)
	}
}
</script>
<VPButton :text="`运行测试代码${count}`" @click="debounce(()=>count++, 2000)"/>

## 节流

节流是高频事件触发，但在n秒内只会执行一次，如果n秒内触发多次函数，只有一次生效，节流会稀释函数的执行频率。



函数实现：

::: code-group

```js [节流函数]
function throttle(fn, delay) {
    let timer = null;
    return function () {
        if (timer) return;
        timer = setTimeout(function () {
            fn.apply(this, arguments);
            timer = null;
        }, delay)
    }
}
```

```js [测试]
function throttle(fn, delay) {
    let timer = null;
    return function () {
        if (timer) return;
        timer = setTimeout(function () {
            fn.apply(this, arguments);
            timer = null;
        }, delay)
    }
}
```

:::



## 对比图

![img](http://oss.chengzz.com/typora_img/202308031033380.png?imageView2/0/q/75%7Cwatermark/1/image/aHR0cHM6Ly93d3cuY2hlbmd6ei5jb20vd2F0ZXJtYXJrLnBuZw==/dissolve/65/gravity/SouthEast/dx/10/dy/10)